{"name":"Go1","tagline":"goroutine study simply","body":"`golang中的协程`  \r\n\r\n首先说一下协程的概念：\r\n===\r\n　　所谓协程就是轻量级的线程，其实我理解的就是一个函数．   \r\n\r\n\r\n协程与线程进程的对比：   \r\n===\r\n　　协成是比线程和进程更加轻量级的，就相当于一个函数一样．系统的开销小．   \r\n\r\n协程是如何管理：   \r\n===\r\n　　协成采用的是段拷贝的方式进行协成栈的管理的，我们都知道在ｃ语言中的递归函数有时候会出现栈溢出，\r\n　　原因就是每次都会为其分配新的函数栈空间当递归过多的话会发生溢出，而ｇｏ解决了这个问题，\r\n　　使用了(段拷贝技术)[http://tonybai.com/2014/11/05/how-stacks-are-handled-in-go/]．     \r\n\r\n  \r\ngo中协成的启动：   \r\n===\r\n　　　go function_name();    \r\n　　　这就相当于启动了一个协程．语法很简单的．    \r\n\r\n协成之间的同步和通信：   \r\n===\r\n　　　在go语言中使用channel进行同步和通信．相当于linux中的管道．   \r\n  \r\n* 无缓冲的：\r\n \r\n```\r\n  1 package main\r\n  2 var a string\r\n  3 var c = make(chan int)\r\n  4 func f() {\r\n  5     a = \"hello, world\"\r\n  6     <-c\r\n  7 }\r\n  8   \r\n  9 func main() {\r\n 10     go f()\r\n 11     c <- 0\r\n 12     print(a)\r\n 13  \r\n 14 }\r\n```\r\n\r\n* 有缓冲的：   \r\n```lua  \r\n  1 package main\r\n  2 var a string\r\n  3 var c = make(chan int,10)\r\n  4 func f() {\r\n  5     a = \"hello, world\"\r\n  6     c<-0\r\n  7 }\r\n  8   \r\n  9 func main() {\r\n 10     go f()\r\n 11      <-c\r\n 12     print(a)\r\n 13  \r\n 14 }\r\n```\r\n\r\ngo中select机制：   \r\n===\r\n　　 select是干什么的恩？大家都知道linux中的select poll epoll等，其实go中的select也差不多有类似的功能\r\n只不过go　中的select是监听多个channel上是否有数据流动．即当有多个channel的时候可以使用select进行相\r\n应的监听，当谁发生了则执行谁，当多个channel同时发生则进行随机的选择一个．     \r\n如下：   \r\n\r\n```lua\r\nfunc main(){\r\n    c := make(chan int)\r\n    b := make(chan bool)\r\n    go func (){\r\n\r\n    for {\r\n       select {\r\n           case v := <-c:\r\n              printfln(v)\r\n           case <- time.After(5*time.Second):\r\n              b <- true\r\n              break\r\n        }\r\n   }()\r\n\r\n   <- b\r\n\r\n}\r\n```\r\n\r\n上面函数就简单的实现了一个防止进入阻塞的情况．   \r\n\r\n\r\n* 定时器：    \r\n```lua\r\nfunc demo(input chan interface{}) {\r\n    t1 := time.NewTimer(time.Second * 5)\r\n    t2 := time.NewTimer(time.Second * 10)\r\n\r\n    for {\r\n        select {\r\n        case msg <- input:\r\n            println(msg)\r\n\r\n        case <-t1.C:\r\n            println(\"5s timer\")\r\n            t1.Reset(time.Second * 5)\r\n\r\n        case <-t2.C:\r\n            println(\"10s timer\")\r\n            t2.Reset(time.Second * 10)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n值得注意的是：      \r\n\r\n   * t1 := time.NewTimer(time.Second * 5)   \r\n   * t2 := time.NewTimer(time.Second * 10)     \r\n                                     \r\n　　这两个是一个全局的，而不像＂case <- time.After(5*time.Second)＂，这是由于每次循环的时候重新执行\r\n　　case 条件语句并重新注册到 select 中，因此这每次执行 select 的时候，都是启动了一个新的从头开始计\r\n　　时的 Timer 对象，所以在这里定义了两个全局的．    \r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"goroutine  channel select ","note":"Don't delete this file! It's used internally to help with page regeneration."}